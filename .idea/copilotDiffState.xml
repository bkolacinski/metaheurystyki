<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/zadanie2/src/algorithm.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/zadanie2/src/algorithm.py" />
              <option name="originalContent" value="from collections.abc import Callable&#10;from math import exp&#10;from random import uniform&#10;&#10;&#10;class SimulatedAnnealing:&#10;    def __init__(self,&#10;                 func: Callable,&#10;                 domain: tuple[float, float] | list[tuple[float, float]]):&#10;        self.func = func&#10;        if isinstance(domain, tuple) and len(domain) == 2 and isinstance(&#10;                domain[0], (int, float)):&#10;            self.domain = [domain]&#10;        else:&#10;            self.domain = domain&#10;        self.dimensions = len(self.domain)&#10;&#10;    def run_epochs(self,&#10;                   epochs: int,&#10;                   attempts_per_epoch: int,&#10;                   init_temp: float,&#10;                   alpha: Callable[[float], float],&#10;                   k: float) -&gt; tuple[list[float], float]:&#10;&#10;        best_point = [uniform(self.domain[i][0], self.domain[i][1])&#10;                      for i in range(self.dimensions)]&#10;        best_f_value = self.func(*best_point)&#10;        temp = init_temp&#10;&#10;        for _ in range(epochs):&#10;            for _ in range(attempts_per_epoch):&#10;                new_point = []&#10;                for i in range(self.dimensions):&#10;                    left, right = self.domain[i]&#10;                    new_coord = uniform(best_point[i] - 2 * temp,&#10;                                        best_point[i] + 2 * temp)&#10;                    new_coord = max(left, min(new_coord, right))&#10;                    new_point.append(new_coord)&#10;&#10;                f_value = self.func(*new_point)&#10;&#10;                if f_value &gt; best_f_value:&#10;                    best_point, best_f_value = new_point, f_value&#10;                else:&#10;                    if exp((f_value - best_f_value) / (k * temp)) &gt; uniform(0, 1):&#10;                        best_point, best_f_value = new_point, f_value&#10;&#10;            temp = alpha(temp)&#10;&#10;        return best_point, best_f_value&#10;" />
              <option name="updatedContent" value="from collections.abc import Callable&#10;from math import exp&#10;from random import uniform&#10;&#10;&#10;class SimulatedAnnealing:&#10;    def __init__(self,&#10;                 func: Callable,&#10;                 domain: tuple[float, float] | list[tuple[float, float]]):&#10;        self.func = func&#10;        if isinstance(domain, tuple) and len(domain) == 2 and isinstance(&#10;                domain[0], (int, float)):&#10;            self.domain = [domain]&#10;        else:&#10;            self.domain = domain&#10;        self.dimensions = len(self.domain)&#10;&#10;    def run_epochs(self,&#10;                   epochs: int,&#10;                   attempts_per_epoch: int,&#10;                   init_temp: float,&#10;                   alpha: Callable[[float], float],&#10;                   k: float) -&gt; tuple[list[float], float]:&#10;&#10;        best_point = [uniform(self.domain[i][0], self.domain[i][1])&#10;                      for i in range(self.dimensions)]&#10;        best_f_value = self.func(*best_point)&#10;        temp = init_temp&#10;&#10;        for _ in range(epochs):&#10;            for _ in range(attempts_per_epoch):&#10;                new_point = []&#10;                for i in range(self.dimensions):&#10;                    left, right = self.domain[i]&#10;                    new_coord = uniform(best_point[i] - 2 * temp,&#10;                                        best_point[i] + 2 * temp)&#10;                    new_coord = max(left, min(new_coord, right))&#10;                    new_point.append(new_coord)&#10;&#10;                f_value = self.func(*new_point)&#10;&#10;                if f_value &gt; best_f_value:&#10;                    best_point, best_f_value = new_point, f_value&#10;                else:&#10;                    if exp((f_value - best_f_value) / (k * temp)) &gt; uniform(0, 1):&#10;                        best_point, best_f_value = new_point, f_value&#10;&#10;            temp = alpha(temp)&#10;&#10;        return best_point, best_f_value&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/zadanie2/src/run.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/zadanie2/src/run.py" />
              <option name="originalContent" value="from algorithm import SimulatedAnnealing&#10;from funcs import *&#10;&#10;&#10;def main():&#10;&#10;    # Example from lecture&#10;    annealing_example_1 = SimulatedAnnealing(&#10;        func=example_1,&#10;        domain=(0, 10)&#10;    )&#10;    point, value = annealing_example_1.run_epochs(&#10;        epochs=50,&#10;        attempts_per_epoch=50,&#10;        init_temp=5.0,&#10;        alpha=lambda t: 0.9 * t,&#10;        k=1.0&#10;    )&#10;    print(f'x: {point[0]: .4f}, f(x): {value: .4f}')&#10;&#10;    # One of the functions from section 3&#10;    annealing_section_3 = SimulatedAnnealing(&#10;        func=func_section_3,&#10;        domain=(-150, 150)&#10;    )&#10;    point, value = annealing_section_3.run_epochs(&#10;        epochs=5000,&#10;        attempts_per_epoch=1,&#10;        init_temp=500.0,&#10;        alpha=lambda t: 0.999 * t,&#10;        k=0.1&#10;    )&#10;    print(f'x: {point[0]: .4f}, f(x): {value: .4f}')&#10;&#10;    # One of the functions from section 4&#10;    annealing_section_4 = SimulatedAnnealing(&#10;        func=func_section_4,&#10;        domain=[(-3, 12), (4.1, 5.8)]&#10;    )&#10;    point, value = annealing_section_4.run_epochs(&#10;        epochs=7000,&#10;        attempts_per_epoch=1,&#10;        init_temp=100.0,&#10;        alpha=lambda t: 0.999 * t,&#10;        k=0.2&#10;    )&#10;    print(f'x: {point[0]: .4f}, y: {point[1]: .4f}, f(x,y): {value: .4f}')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="from algorithm import SimulatedAnnealing&#10;from funcs import *&#10;&#10;&#10;def main():&#10;&#10;    # Example from lecture&#10;    annealing_example_1 = SimulatedAnnealing(&#10;        func=example_1,&#10;        domain=(0, 10)&#10;    )&#10;    point, value = annealing_example_1.run_epochs(&#10;        epochs=50,&#10;        attempts_per_epoch=50,&#10;        init_temp=5.0,&#10;        alpha=lambda t: 0.9 * t,&#10;        k=1.0&#10;    )&#10;    print(f'x: {point[0]: .4f}, f(x): {value: .4f}')&#10;&#10;    # One of the functions from section 3&#10;    annealing_section_3 = SimulatedAnnealing(&#10;        func=func_section_3,&#10;        domain=(-150, 150)&#10;    )&#10;    point, value = annealing_section_3.run_epochs(&#10;        epochs=5000,&#10;        attempts_per_epoch=1,&#10;        init_temp=500.0,&#10;        alpha=0.999,&#10;        k=0.1&#10;    )&#10;    print(f'x: {point[0]: .4f}, f(x): {value: .4f}')&#10;&#10;    # One of the functions from section 4&#10;    annealing_section_4 = SimulatedAnnealing(&#10;        func=func_section_4,&#10;        domain=[(-3, 12), (4.1, 5.8)]&#10;    )&#10;    point, value = annealing_section_4.run_epochs(&#10;        epochs=7000,&#10;        attempts_per_epoch=1,&#10;        init_temp=100.0,&#10;        alpha=lambda t: 0.999 * t,&#10;        k=0.2&#10;    )&#10;    print(f'x: {point[0]: .4f}, y: {point[1]: .4f}, f(x,y): {value: .4f}')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>