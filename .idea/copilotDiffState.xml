<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/zadanie3/src/plots.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/zadanie3/src/plots.py" />
              <option name="originalContent" value="import os&#10;from pathlib import Path&#10;&#10;import matplotlib.pyplot as plt&#10;import matplotlib.ticker as ticker&#10;import numpy as np&#10;import pandas as pd&#10;&#10;&#10;def bar_plot(max_data: dict,&#10;             avg_data: dict,&#10;             title: str,&#10;             xlabel: str,&#10;             ylabel: str,&#10;             filename: str) -&gt; None:&#10;    labels = list(max_data.keys())&#10;    max_values = list(max_data.values())&#10;    avg_values = list(avg_data.values())&#10;&#10;    labels_spread = np.arange(len(labels))&#10;&#10;    _, ax = plt.subplots(figsize=(8, 5))&#10;&#10;    bars_max = ax.bar(&#10;        labels_spread,&#10;        max_values,&#10;        width=0.6,&#10;        color='green',&#10;        alpha=0.7,&#10;        label='Max')&#10;&#10;    bars_avg = ax.bar(&#10;        labels_spread,&#10;        avg_values,&#10;        width=0.6,&#10;        color='orange',&#10;        alpha=0.8,&#10;        label='Avg')&#10;&#10;    ax.set_xlabel(xlabel)&#10;    ax.set_ylabel(ylabel)&#10;    ax.set_title(title)&#10;    ax.set_xticks(labels_spread)&#10;    ax.set_xticklabels(labels, rotation=45, ha='right')&#10;    ax.set_yscale('log')&#10;    ax.legend()&#10;&#10;    all_values = max_values + avg_values&#10;    y_min, y_max = min(all_values), max(all_values)&#10;    y_range = y_max - y_min&#10;&#10;    if y_range &gt; 0:&#10;        log_y_min = np.log10(y_min)&#10;        log_y_max = np.log10(y_max)&#10;        log_range = log_y_max - log_y_min&#10;&#10;        margin = log_range * 0.05&#10;&#10;        ax.set_ylim(&#10;            10 ** (log_y_min - margin),&#10;            10 ** (log_y_max + margin)&#10;        )&#10;&#10;        log_ticks = np.linspace(log_y_min, log_y_max, 5)&#10;        tick_values = [10 ** x for x in log_ticks]&#10;&#10;        ax.yaxis.set_major_locator(&#10;            ticker.FixedLocator(tick_values))&#10;        ax.yaxis.set_minor_locator(ticker.NullLocator())&#10;&#10;        ax.yaxis.set_major_formatter(ticker.FuncFormatter(&#10;            lambda x, _: f'{int(x):,}' if x &gt;= 1 else f'{x:.2e}'&#10;        ))&#10;&#10;    ax.grid(True, which='major', alpha=0.3, axis='y')&#10;&#10;    for bars, values in [(bars_max, max_values), (bars_avg, avg_values)]:&#10;        for bar, val in zip(bars, values):&#10;            ax.annotate(f'{int(val)}', ha='center', va='bottom',&#10;                        xy=(bar.get_x() + bar.get_width() / 2, val),&#10;                        xytext=(0, 1), textcoords=&quot;offset points&quot;,&#10;                        fontsize=8, color='black')&#10;&#10;    plt.tight_layout()&#10;    plt.savefig(f&quot;../plots/{filename}&quot;)&#10;    plt.close()&#10;&#10;&#10;def plot_over_time(csv_filename: str,&#10;                   filename: str,&#10;                   config_name: str):&#10;    df = pd.read_csv(f&quot;../results/{csv_filename}.csv&quot;)&#10;&#10;    best_fitness_per_run = df.groupby('run_id')['best_fitness'].max()&#10;    best_run_id = best_fitness_per_run.idxmax()&#10;&#10;    history_df = df[df['run_id'] ==&#10;                    best_run_id].sort_values(by='iteration')&#10;&#10;    history = []&#10;    for _, row in history_df.iterrows():&#10;        history.append({&#10;            'iteration': int(row['iteration']),&#10;            'best_fitness': row['best_fitness'],&#10;            'avg_fitness': row['avg_fitness'],&#10;            'worst_fitness': row['worst_fitness']&#10;        })&#10;&#10;    _, axes = plt.subplots(nrows=3, ncols=1, figsize=(12, 10))&#10;&#10;    metrics = {&#10;        0: {&#10;            'data': [h['best_fitness'] for h in history],&#10;            'label': 'Najlepszy Fitness',&#10;            'title': 'Najlepszy Fitness',&#10;            'color': 'green'&#10;        },&#10;        1: {&#10;            'data': [h['avg_fitness'] for h in history],&#10;            'label': 'Średni Fitness',&#10;            'title': 'Średni Fitness',&#10;            'color': 'blue'&#10;        },&#10;        2: {&#10;            'data': [h['worst_fitness'] for h in history],&#10;            'label': 'Najgorszy Fitness',&#10;            'title': 'Najgorszy Fitness',&#10;            'color': 'red'&#10;        }&#10;    }&#10;&#10;    iterations = [h['iteration'] for h in history]&#10;&#10;    for idx, metric in metrics.items():&#10;        axes[idx].plot(iterations, metric['data'],&#10;                       label=metric['label'], color=metric['color'])&#10;        axes[idx].set_xlabel('Iteracja')&#10;        axes[idx].set_ylabel('Fitness')&#10;        axes[idx].set_title(f&quot;{metric['title']} - {config_name}&quot;)&#10;        axes[idx].set_yscale('log')&#10;&#10;        y_min, y_max = min(metric['data']), max(metric['data'])&#10;        y_range = y_max - y_min&#10;&#10;        if y_range &gt; 0:&#10;            log_y_min = np.log10(y_min)&#10;            log_y_max = np.log10(y_max)&#10;            log_range = log_y_max - log_y_min&#10;&#10;            margin = log_range * 0.05&#10;&#10;            axes[idx].set_ylim(&#10;                10 ** (log_y_min - margin),&#10;                10 ** (log_y_max + margin)&#10;            )&#10;&#10;            log_ticks = np.linspace(log_y_min, log_y_max, 5)&#10;            tick_values = [10 ** x for x in log_ticks]&#10;&#10;            axes[idx].yaxis.set_major_locator(&#10;                ticker.FixedLocator(tick_values))&#10;            axes[idx].yaxis.set_minor_locator(ticker.NullLocator())&#10;&#10;            axes[idx].yaxis.set_major_formatter(ticker.FuncFormatter(&#10;                lambda x, p: f'{int(x):,}' if x &gt;= 1 else f'{x:.2e}'&#10;            ))&#10;&#10;        axes[idx].legend()&#10;        axes[idx].grid(True, which='major', alpha=0.3)&#10;&#10;    plt.tight_layout()&#10;    plt.savefig(f&quot;../plots/{filename}&quot;)&#10;    plt.close()&#10;&#10;    print(f&quot;  Wykres zapisany: ../plots/{filename}&quot;)&#10;&#10;&#10;def analyze_csv_results(&#10;        results_dir: str = &quot;../results&quot;, verbose: bool = True) -&gt; dict:&#10;    results = {}&#10;&#10;    csv_files = sorted(Path(results_dir).glob(&quot;*.csv&quot;))&#10;&#10;    for csv_file in csv_files:&#10;        filename = csv_file.stem&#10;&#10;        df = pd.read_csv(csv_file)&#10;&#10;        best_fitness = df['best_fitness'].max()&#10;&#10;        best_fitness_per_run = df.groupby(&#10;            'run_id')['best_fitness'].max()&#10;        avg_best_fitness = best_fitness_per_run.mean()&#10;&#10;        results[filename] = {&#10;            'best_fitness': best_fitness,&#10;            'avg_best_fitness': avg_best_fitness&#10;        }&#10;&#10;        if verbose:&#10;            print(f&quot;\n{filename}:&quot;)&#10;            print(f&quot;Best fitness: {best_fitness:,.0f}&quot;)&#10;            print(f&quot;Avg best fitness: {avg_best_fitness:,.2f}&quot;)&#10;            print(f&quot;Number of runs: {len(best_fitness_per_run)}&quot;)&#10;&#10;    return results&#10;&#10;&#10;def find_best_worst_by_prefix(results: dict) -&gt; dict:&#10;    tour_results = {&#10;        k: v for k,&#10;        v in results.items() if k.startswith('Tour')}&#10;    roul_results = {&#10;        k: v for k,&#10;        v in results.items() if k.startswith('Roul')}&#10;&#10;    tour_best = max(&#10;        tour_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;    tour_worst = min(&#10;        tour_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;&#10;    roul_best = max(&#10;        roul_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;    roul_worst = min(&#10;        roul_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;&#10;    selected = {&#10;        'Tour_Best': (tour_best[0], tour_best[1]),&#10;        'Tour_Worst': (tour_worst[0], tour_worst[1]),&#10;        'Roul_Best': (roul_best[0], roul_best[1]),&#10;        'Roul_Worst': (roul_worst[0], roul_worst[1])&#10;    }&#10;&#10;    print(f&quot;\n\n{'=' * 80}&quot;)&#10;    print(&quot;WYBRANE KONFIGURACJE DO WIZUALIZACJI&quot;)&#10;    print(f&quot;{'=' * 80}&quot;)&#10;&#10;    for label, (config, data) in selected.items():&#10;        print(f&quot;\n{label}:&quot;)&#10;        print(f&quot;Konfiguracja: {config}&quot;)&#10;        print(f&quot;Best fitness: {data['best_fitness']:,.0f}&quot;)&#10;        print(f&quot;Avg best fitness: {data['avg_best_fitness']:,.2f}&quot;)&#10;&#10;    return selected&#10;&#10;&#10;def plot_selected_configurations(selected: dict) -&gt; None:&#10;    os.makedirs('../plots', exist_ok=True)&#10;&#10;    max_data = {}&#10;    avg_data = {}&#10;&#10;    for label, (_, data_stats) in selected.items():&#10;        short_label = label&#10;        max_data[short_label] = data_stats['best_fitness']&#10;        avg_data[short_label] = data_stats['avg_best_fitness']&#10;&#10;    bar_plot(&#10;        max_data=max_data,&#10;        avg_data=avg_data,&#10;        title=&quot;Porównanie najlepszych i najgorszych konfiguracji&quot;,&#10;        xlabel=&quot;Konfiguracja&quot;,&#10;        ylabel=&quot;Fitness&quot;,&#10;        filename=&quot;comparison_bar_plot.png&quot;&#10;    )&#10;&#10;    print(f&quot;\nWykres słupkowy zapisany: ../plots/comparison_bar_plot.png&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;GENEROWANIE WYKRESÓW OVER-TIME DLA WYBRANYCH KONFIGURACJI&quot;)&#10;    print(f&quot;{'=' * 80}&quot;)&#10;&#10;    for label, (config_name, _) in selected.items():&#10;        print(f&quot;\nGenerowanie wykresu dla {label} ({config_name})...&quot;)&#10;&#10;        plot_over_time(&#10;            csv_filename=config_name,&#10;            filename=f&quot;{label}_over_time.png&quot;,&#10;            config_name=config_name&#10;        )&#10;&#10;&#10;def parse_filename(filename: str) -&gt; dict:&#10;    parts = filename.replace('.csv', '').split('_')&#10;&#10;    params = {}&#10;    for part in parts:&#10;        if part.startswith('cp'):&#10;            params['cross_prob'] = float(part[2:])&#10;        elif part.startswith('mp'):&#10;            params['mutation_prob'] = float(part[2:])&#10;        elif part.startswith('pop'):&#10;            params['population'] = int(part[3:])&#10;        elif part.startswith('it'):&#10;            params['iterations'] = int(part[2:])&#10;&#10;    if parts[0] in ['Tour', 'Roul']:&#10;        params['selection'] = parts[0]&#10;    if len(parts) &gt; 1 and parts[1] in ['1P', '2P']:&#10;        params['crossover'] = parts[1]&#10;&#10;    return params&#10;&#10;&#10;def plot_parameter_influence(results_dir: str = &quot;../results&quot;) -&gt; None:&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;ANALIZA WPŁYWU PARAMETRÓW&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    csv_files = sorted(Path(results_dir).glob(&quot;*.csv&quot;))&#10;&#10;    all_data = []&#10;    for csv_file in csv_files:&#10;        df = pd.read_csv(csv_file)&#10;        params = parse_filename(csv_file.name)&#10;&#10;        best_fitness_per_run = df.groupby('run_id')['best_fitness'].max()&#10;&#10;        for fitness in best_fitness_per_run:&#10;            all_data.append({&#10;                'cross_prob': params.get('cross_prob'),&#10;                'mutation_prob': params.get('mutation_prob'),&#10;                'population': params.get('population'),&#10;                'best_fitness': fitness&#10;            })&#10;&#10;    df_all = pd.DataFrame(all_data)&#10;&#10;    print(&quot;\nGenerowanie wykresu: wpływ Pc...&quot;)&#10;    pc_values = sorted(df_all['cross_prob'].unique())&#10;    pc_data = [df_all[df_all['cross_prob'] == pc]['best_fitness'].values for pc in pc_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pc_data, tick_labels=[f'{pc:.1f}' for pc in pc_values])&#10;    ax.set_xlabel('Prawdopodobieństwo krzyżowania (Pc)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ prawdopodobieństwa krzyżowania na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_cross_probability.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_cross_probability.png&quot;)&#10;&#10;    print(&quot;Generowanie wykresu: wpływ Pm...&quot;)&#10;    pm_values = sorted(df_all['mutation_prob'].unique())&#10;    pm_data = [df_all[df_all['mutation_prob'] == pm]['best_fitness'].values for pm in pm_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pm_data, tick_labels=[f'{pm:.2f}' for pm in pm_values])&#10;    ax.set_xlabel('Prawdopodobieństwo mutacji (Pm)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ prawdopodobieństwa mutacji na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_mutation_probability.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_mutation_probability.png&quot;)&#10;&#10;    print(&quot;Generowanie wykresu: wpływ N...&quot;)&#10;    pop_values = sorted(df_all['population'].unique())&#10;    pop_data = [df_all[df_all['population'] == pop]['best_fitness'].values for pop in pop_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pop_data, tick_labels=[f'{pop}' for pop in pop_values])&#10;    ax.set_xlabel('Wielkość populacji (N)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ wielkości populacji na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_population_size.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_population_size.png&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;-&quot; * 80)&#10;    print(&quot;STATYSTYKI WPŁYWU PARAMETRÓW:&quot;)&#10;    print(&quot;-&quot; * 80)&#10;&#10;    print(&quot;\n1. Prawdopodobieństwo krzyżowania (Pc):&quot;)&#10;    for pc in pc_values:&#10;        data = df_all[df_all['cross_prob'] == pc]['best_fitness']&#10;        print(f&quot;Pc={pc:.1f}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;    print(&quot;\n2. Prawdopodobieństwo mutacji (Pm):&quot;)&#10;    for pm in pm_values:&#10;        data = df_all[df_all['mutation_prob'] == pm]['best_fitness']&#10;        print(f&quot;Pm={pm:.2f}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;    print(&quot;\n3. Wielkość populacji (N):&quot;)&#10;    for pop in pop_values:&#10;        data = df_all[df_all['population'] == pop]['best_fitness']&#10;        print(f&quot;N={pop}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;&#10;def main():&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;ANALIZA WYNIKÓW Z PLIKÓW CSV&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    results = analyze_csv_results(&quot;../results&quot;)&#10;&#10;    print(f&quot;\n\n{'=' * 60}&quot;)&#10;    print(f&quot;Podsumowanie: przeanalizowano {len(results)} plików&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    selected = find_best_worst_by_prefix(results)&#10;&#10;    plot_selected_configurations(selected)&#10;&#10;    plot_parameter_influence(&quot;../results&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;ZAKOŃCZONO - Wszystkie wykresy zapisane w katalogu ../plots/&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;\nWygenerowane pliki:&quot;)&#10;    print(&quot;  1. comparison_bar_plot.png - &quot;&#10;          &quot;wykres słupkowy porównawczy&quot;)&#10;    print(&quot;  2. Tour_Best_over_time.png - &quot;&#10;          &quot;wykres over-time dla najlepszej konfiguracji Tournament&quot;)&#10;    print(&quot;  3. Tour_Worst_over_time.png - &quot;&#10;          &quot;wykres over-time dla najgorszej konfiguracji Tournament&quot;)&#10;    print(&quot;  4. Roul_Best_over_time.png - &quot;&#10;          &quot;wykres over-time dla najlepszej konfiguracji Roulette&quot;)&#10;    print(&quot;  5. Roul_Worst_over_time.png - &quot;&#10;          &quot;wykres over-time dla najgorszej konfiguracji Roulette&quot;)&#10;    print(&quot;  6. influence_cross_probability.png - &quot;&#10;          &quot;box plot wpływu prawdopodobieństwa krzyżowania (Pc)&quot;)&#10;    print(&quot;  7. influence_mutation_probability.png - &quot;&#10;          &quot;box plot wpływu prawdopodobieństwa mutacji (Pm)&quot;)&#10;    print(&quot;  8. influence_population_size.png - &quot;&#10;          &quot;box plot wpływu wielkości populacji (N)&quot;)&#10;    print(&quot;=&quot; * 80 + &quot;\n&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import os&#10;from pathlib import Path&#10;&#10;import matplotlib.pyplot as plt&#10;import matplotlib.ticker as ticker&#10;import numpy as np&#10;import pandas as pd&#10;&#10;&#10;def bar_plot(max_data: dict,&#10;             avg_data: dict,&#10;             title: str,&#10;             xlabel: str,&#10;             ylabel: str,&#10;             filename: str) -&gt; None:&#10;    labels = list(max_data.keys())&#10;    max_values = list(max_data.values())&#10;    avg_values = list(avg_data.values())&#10;&#10;    labels_spread = np.arange(len(labels))&#10;&#10;    _, ax = plt.subplots(figsize=(8, 5))&#10;&#10;    bars_max = ax.bar(&#10;        labels_spread,&#10;        max_values,&#10;        width=0.6,&#10;        color='green',&#10;        alpha=0.7,&#10;        label='Max')&#10;&#10;    bars_avg = ax.bar(&#10;        labels_spread,&#10;        avg_values,&#10;        width=0.6,&#10;        color='orange',&#10;        alpha=0.8,&#10;        label='Avg')&#10;&#10;    ax.set_xlabel(xlabel)&#10;    ax.set_ylabel(ylabel)&#10;    ax.set_title(title)&#10;    ax.set_xticks(labels_spread)&#10;    ax.set_xticklabels(labels, rotation=45, ha='right')&#10;    ax.set_yscale('log')&#10;    ax.legend()&#10;&#10;    all_values = max_values + avg_values&#10;    y_min, y_max = min(all_values), max(all_values)&#10;    y_range = y_max - y_min&#10;&#10;    if y_range &gt; 0:&#10;        log_y_min = np.log10(y_min)&#10;        log_y_max = np.log10(y_max)&#10;        log_range = log_y_max - log_y_min&#10;&#10;        margin = log_range * 0.05&#10;&#10;        ax.set_ylim(&#10;            10 ** (log_y_min - margin),&#10;            10 ** (log_y_max + margin)&#10;        )&#10;&#10;        log_ticks = np.linspace(log_y_min, log_y_max, 5)&#10;        tick_values = [10 ** x for x in log_ticks]&#10;&#10;        ax.yaxis.set_major_locator(&#10;            ticker.FixedLocator(tick_values))&#10;        ax.yaxis.set_minor_locator(ticker.NullLocator())&#10;&#10;        ax.yaxis.set_major_formatter(ticker.FuncFormatter(&#10;            lambda x, _: f'{int(x):,}' if x &gt;= 1 else f'{x:.2e}'&#10;        ))&#10;&#10;    ax.grid(True, which='major', alpha=0.3, axis='y')&#10;&#10;    for bars, values in [(bars_max, max_values), (bars_avg, avg_values)]:&#10;        for bar, val in zip(bars, values):&#10;            ax.annotate(f'{int(val)}', ha='center', va='bottom',&#10;                        xy=(bar.get_x() + bar.get_width() / 2, val),&#10;                        xytext=(0, 1), textcoords=&quot;offset points&quot;,&#10;                        fontsize=8, color='black')&#10;&#10;    plt.tight_layout()&#10;    plt.savefig(f&quot;../plots/{filename}&quot;)&#10;    plt.close()&#10;&#10;&#10;def plot_over_time(csv_filename: str,&#10;                   filename: str,&#10;                   config_name: str):&#10;    df = pd.read_csv(f&quot;../results/{csv_filename}.csv&quot;)&#10;&#10;    best_fitness_per_run = df.groupby('run_id')['best_fitness'].max()&#10;    best_run_id = best_fitness_per_run.idxmax()&#10;&#10;    history_df = df[df['run_id'] ==&#10;                    best_run_id].sort_values(by='iteration')&#10;&#10;    history = []&#10;    for _, row in history_df.iterrows():&#10;        history.append({&#10;            'iteration': int(row['iteration']),&#10;            'best_fitness': row['best_fitness'],&#10;            'avg_fitness': row['avg_fitness'],&#10;            'worst_fitness': row['worst_fitness']&#10;        })&#10;&#10;    _, axes = plt.subplots(nrows=3, ncols=1, figsize=(12, 10))&#10;&#10;    metrics = {&#10;        0: {&#10;            'data': [h['best_fitness'] for h in history],&#10;            'label': 'Najlepszy Fitness',&#10;            'title': 'Najlepszy Fitness',&#10;            'color': 'green'&#10;        },&#10;        1: {&#10;            'data': [h['avg_fitness'] for h in history],&#10;            'label': 'Średni Fitness',&#10;            'title': 'Średni Fitness',&#10;            'color': 'blue'&#10;        },&#10;        2: {&#10;            'data': [h['worst_fitness'] for h in history],&#10;            'label': 'Najgorszy Fitness',&#10;            'title': 'Najgorszy Fitness',&#10;            'color': 'red'&#10;        }&#10;    }&#10;&#10;    iterations = [h['iteration'] for h in history]&#10;&#10;    for idx, metric in metrics.items():&#10;        axes[idx].plot(iterations, metric['data'],&#10;                       label=metric['label'], color=metric['color'])&#10;        axes[idx].set_xlabel('Iteracja')&#10;        axes[idx].set_ylabel('Fitness')&#10;        axes[idx].set_title(f&quot;{metric['title']} - {config_name}&quot;)&#10;        axes[idx].set_yscale('log')&#10;&#10;        y_min, y_max = min(metric['data']), max(metric['data'])&#10;        y_range = y_max - y_min&#10;&#10;        if y_range &gt; 0:&#10;            log_y_min = np.log10(y_min)&#10;            log_y_max = np.log10(y_max)&#10;            log_range = log_y_max - log_y_min&#10;&#10;            margin = log_range * 0.05&#10;&#10;            axes[idx].set_ylim(&#10;                10 ** (log_y_min - margin),&#10;                10 ** (log_y_max + margin)&#10;            )&#10;&#10;            log_ticks = np.linspace(log_y_min, log_y_max, 5)&#10;            tick_values = [10 ** x for x in log_ticks]&#10;&#10;            axes[idx].yaxis.set_major_locator(&#10;                ticker.FixedLocator(tick_values))&#10;            axes[idx].yaxis.set_minor_locator(ticker.NullLocator())&#10;&#10;            axes[idx].yaxis.set_major_formatter(ticker.FuncFormatter(&#10;                lambda x, p: f'{int(x):,}' if x &gt;= 1 else f'{x:.2e}'&#10;            ))&#10;&#10;        axes[idx].legend()&#10;        axes[idx].grid(True, which='major', alpha=0.3)&#10;&#10;    plt.tight_layout()&#10;    plt.savefig(f&quot;../plots/{filename}&quot;)&#10;    plt.close()&#10;&#10;    print(f&quot;  Wykres zapisany: ../plots/{filename}&quot;)&#10;&#10;&#10;def analyze_csv_results(&#10;        results_dir: str = &quot;../results&quot;, verbose: bool = True) -&gt; dict:&#10;    results = {}&#10;&#10;    csv_files = sorted(Path(results_dir).glob(&quot;*.csv&quot;))&#10;&#10;    for csv_file in csv_files:&#10;        filename = csv_file.stem&#10;&#10;        df = pd.read_csv(csv_file)&#10;&#10;        best_fitness = df['best_fitness'].max()&#10;&#10;        best_fitness_per_run = df.groupby(&#10;            'run_id')['best_fitness'].max()&#10;        avg_best_fitness = best_fitness_per_run.mean()&#10;&#10;        results[filename] = {&#10;            'best_fitness': best_fitness,&#10;            'avg_best_fitness': avg_best_fitness&#10;        }&#10;&#10;        if verbose:&#10;            print(f&quot;\n{filename}:&quot;)&#10;            print(f&quot;Best fitness: {best_fitness:,.0f}&quot;)&#10;            print(f&quot;Avg best fitness: {avg_best_fitness:,.2f}&quot;)&#10;            print(f&quot;Number of runs: {len(best_fitness_per_run)}&quot;)&#10;&#10;    return results&#10;&#10;&#10;def find_best_worst_by_prefix(results: dict) -&gt; dict:&#10;    tour_results = {&#10;        k: v for k,&#10;        v in results.items() if k.startswith('Tour')}&#10;    roul_results = {&#10;        k: v for k,&#10;        v in results.items() if k.startswith('Roul')}&#10;&#10;    tour_best = max(&#10;        tour_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;    tour_worst = min(&#10;        tour_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;&#10;    roul_best = max(&#10;        roul_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;    roul_worst = min(&#10;        roul_results.items(),&#10;        key=lambda x: x[1]['best_fitness'])&#10;&#10;    selected = {&#10;        'Tour_Best': (tour_best[0], tour_best[1]),&#10;        'Tour_Worst': (tour_worst[0], tour_worst[1]),&#10;        'Roul_Best': (roul_best[0], roul_best[1]),&#10;        'Roul_Worst': (roul_worst[0], roul_worst[1])&#10;    }&#10;&#10;    print(f&quot;\n\n{'=' * 80}&quot;)&#10;    print(&quot;WYBRANE KONFIGURACJE DO WIZUALIZACJI&quot;)&#10;    print(f&quot;{'=' * 80}&quot;)&#10;&#10;    for label, (config, data) in selected.items():&#10;        print(f&quot;\n{label}:&quot;)&#10;        print(f&quot;Konfiguracja: {config}&quot;)&#10;        print(f&quot;Best fitness: {data['best_fitness']:,.0f}&quot;)&#10;        print(f&quot;Avg best fitness: {data['avg_best_fitness']:,.2f}&quot;)&#10;&#10;    return selected&#10;&#10;&#10;def plot_selected_configurations(selected: dict) -&gt; None:&#10;    os.makedirs('../plots', exist_ok=True)&#10;&#10;    max_data = {}&#10;    avg_data = {}&#10;&#10;    for label, (_, data_stats) in selected.items():&#10;        short_label = label&#10;        max_data[short_label] = data_stats['best_fitness']&#10;        avg_data[short_label] = data_stats['avg_best_fitness']&#10;&#10;    bar_plot(&#10;        max_data=max_data,&#10;        avg_data=avg_data,&#10;        title=&quot;Porównanie najlepszych i najgorszych konfiguracji&quot;,&#10;        xlabel=&quot;Konfiguracja&quot;,&#10;        ylabel=&quot;Fitness&quot;,&#10;        filename=&quot;comparison_bar_plot.png&quot;&#10;    )&#10;&#10;    print(f&quot;\nWykres słupkowy zapisany: ../plots/comparison_bar_plot.png&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;GENEROWANIE WYKRESÓW OVER-TIME DLA WYBRANYCH KONFIGURACJI&quot;)&#10;    print(f&quot;{'=' * 80}&quot;)&#10;&#10;    for label, (config_name, _) in selected.items():&#10;        print(f&quot;\nGenerowanie wykresu dla {label} ({config_name})...&quot;)&#10;&#10;        plot_over_time(&#10;            csv_filename=config_name,&#10;            filename=f&quot;{label}_over_time.png&quot;,&#10;            config_name=config_name&#10;        )&#10;&#10;&#10;def parse_filename(filename: str) -&gt; dict:&#10;    parts = filename.replace('.csv', '').split('_')&#10;&#10;    params = {}&#10;    for part in parts:&#10;        if part.startswith('cp'):&#10;            params['cross_prob'] = float(part[2:])&#10;        elif part.startswith('mp'):&#10;            params['mutation_prob'] = float(part[2:])&#10;        elif part.startswith('pop'):&#10;            params['population'] = int(part[3:])&#10;        elif part.startswith('it'):&#10;            params['iterations'] = int(part[2:])&#10;&#10;    if parts[0] in ['Tour', 'Roul']:&#10;        params['selection'] = parts[0]&#10;    if len(parts) &gt; 1 and parts[1] in ['1P', '2P']:&#10;        params['crossover'] = parts[1]&#10;&#10;    return params&#10;&#10;&#10;def plot_parameter_influence(results_dir: str = &quot;../results&quot;) -&gt; None:&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;ANALIZA WPŁYWU PARAMETRÓW&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    csv_files = sorted(Path(results_dir).glob(&quot;*.csv&quot;))&#10;&#10;    all_data = []&#10;    for csv_file in csv_files:&#10;        df = pd.read_csv(csv_file)&#10;        params = parse_filename(csv_file.name)&#10;&#10;        best_fitness_per_run = df.groupby('run_id')['best_fitness'].max()&#10;&#10;        for fitness in best_fitness_per_run:&#10;            all_data.append({&#10;                'cross_prob': params.get('cross_prob'),&#10;                'mutation_prob': params.get('mutation_prob'),&#10;                'population': params.get('population'),&#10;                'best_fitness': fitness&#10;            })&#10;&#10;    df_all = pd.DataFrame(all_data)&#10;&#10;    print(&quot;\nGenerowanie wykresu: wpływ Pc...&quot;)&#10;    pc_values = sorted(df_all['cross_prob'].unique())&#10;    pc_data = [df_all[df_all['cross_prob'] == pc]['best_fitness'].values for pc in pc_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pc_data, tick_labels=[f'{pc:.1f}' for pc in pc_values])&#10;    ax.set_xlabel('Prawdopodobieństwo krzyżowania (Pc)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ prawdopodobieństwa krzyżowania na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_cross_probability.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_cross_probability.png&quot;)&#10;&#10;    print(&quot;Generowanie wykresu: wpływ Pm...&quot;)&#10;    pm_values = sorted(df_all['mutation_prob'].unique())&#10;    pm_data = [df_all[df_all['mutation_prob'] == pm]['best_fitness'].values for pm in pm_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pm_data, tick_labels=[f'{pm:.2f}' for pm in pm_values])&#10;    ax.set_xlabel('Prawdopodobieństwo mutacji (Pm)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ prawdopodobieństwa mutacji na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_mutation_probability.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_mutation_probability.png&quot;)&#10;&#10;    print(&quot;Generowanie wykresu: wpływ N...&quot;)&#10;    pop_values = sorted(df_all['population'].unique())&#10;    pop_data = [df_all[df_all['population'] == pop]['best_fitness'].values for pop in pop_values]&#10;&#10;    fig, ax = plt.subplots(figsize=(10, 7))&#10;    ax.boxplot(pop_data, tick_labels=[f'{pop}' for pop in pop_values])&#10;    ax.set_xlabel('Wielkość populacji (N)', fontsize=14)&#10;    ax.set_ylabel('Fitness', fontsize=14)&#10;    ax.set_title('Wpływ wielkości populacji na wyniki', fontsize=16, fontweight='bold')&#10;    ax.grid(True, alpha=0.3, axis='y')&#10;    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, p: f'{int(x):,}'))&#10;&#10;    plt.tight_layout()&#10;    plt.savefig('../plots/influence_population_size.png', dpi=300)&#10;    plt.close()&#10;    print(&quot;Zapisano: ../plots/influence_population_size.png&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;-&quot; * 80)&#10;    print(&quot;STATYSTYKI WPŁYWU PARAMETRÓW:&quot;)&#10;    print(&quot;-&quot; * 80)&#10;&#10;    print(&quot;\n1. Prawdopodobieństwo krzyżowania (Pc):&quot;)&#10;    for pc in pc_values:&#10;        data = df_all[df_all['cross_prob'] == pc]['best_fitness']&#10;        print(f&quot;Pc={pc:.1f}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;    print(&quot;\n2. Prawdopodobieństwo mutacji (Pm):&quot;)&#10;    for pm in pm_values:&#10;        data = df_all[df_all['mutation_prob'] == pm]['best_fitness']&#10;        print(f&quot;Pm={pm:.2f}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;    print(&quot;\n3. Wielkość populacji (N):&quot;)&#10;    for pop in pop_values:&#10;        data = df_all[df_all['population'] == pop]['best_fitness']&#10;        print(f&quot;N={pop}: średnia={data.mean():,.0f}, mediana={data.median():,.0f}, &quot;&#10;              f&quot;std={data.std():,.0f}, min={data.min():,.0f}, max={data.max():,.0f}&quot;)&#10;&#10;&#10;def main():&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;ANALIZA WYNIKÓW Z PLIKÓW CSV&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    results = analyze_csv_results(&quot;../results&quot;)&#10;&#10;    print(f&quot;\n\n{'=' * 60}&quot;)&#10;    print(f&quot;Podsumowanie: przeanalizowano {len(results)} plików&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    selected = find_best_worst_by_prefix(results)&#10;&#10;    plot_selected_configurations(selected)&#10;&#10;    plot_parameter_influence(&quot;../results&quot;)&#10;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;ZAKOŃCZONO - Wszystkie wykresy zapisane w katalogu ../plots/&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;\nWygenerowane pliki:&quot;)&#10;    print(&quot;  1. comparison_bar_plot.png - &quot;&#10;          &quot;wykres słupkowy porównawczy&quot;)&#10;    print(&quot;  2. Tour_Best_over_time.png - &quot;&#10;          &quot;wykres over-time dla najlepszej konfiguracji Tournament&quot;)&#10;    print(&quot;  3. Tour_Worst_over_time.png - &quot;&#10;          &quot;wykres over-time dla najgorszej konfiguracji Tournament&quot;)&#10;    print(&quot;  4. Roul_Best_over_time.png - &quot;&#10;          &quot;wykres over-time dla najlepszej konfiguracji Roulette&quot;)&#10;    print(&quot;  5. Roul_Worst_over_time.png - &quot;&#10;          &quot;wykres over-time dla najgorszej konfiguracji Roulette&quot;)&#10;    print(&quot;  6. influence_cross_probability.png - &quot;&#10;          &quot;box plot wpływu prawdopodobieństwa krzyżowania (Pc)&quot;)&#10;    print(&quot;  7. influence_mutation_probability.png - &quot;&#10;          &quot;box plot wpływu prawdopodobieństwa mutacji (Pm)&quot;)&#10;    print(&quot;  8. influence_population_size.png - &quot;&#10;          &quot;box plot wpływu wielkości populacji (N)&quot;)&#10;    print(&quot;=&quot; * 80 + &quot;\n&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>