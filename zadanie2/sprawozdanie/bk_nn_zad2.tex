\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[a4paper, margin=3cm]{geometry}
\usepackage{array}
\usepackage{tocloft}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Kod}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue
}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\begin{document}
    \title{Metaheurystyki --- zadanie 2 \\
    \large Algorytm symulowanego wyżarzania \\
    \small GRUPA 3 --- piątek 10:15}
    \date{\today}
    \author{
        Bartosz Kołaciński \\
        251554
        \and
        Nikodem Nowak \\
        251598
    }
    \maketitle

    \vfill
    \begin{center}
        \begin{tabular}{lr}
            \toprule
            \textbf{Użyte technologie} & Python 3.13 \\
            \midrule
            \textbf{Użyte biblioteki} & \begin{tabular}[t]{@{}r@{}}
                random, collections.abc, \\
                time, math, numpy, \\
                matplotlib.pyplot
            \end{tabular} \\
            \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1cm}

    \newpage

    \tableofcontents

    \newpage
    \section{Opis zasad działania algorytmu}
    \subsection{Opis algorytmu symulowanego wyżarzania}

    \subsection{Opis implementacji rozwiązania}

    Cała logika algorytmu symulowanego wyżarzania została zaimplementowana w klasie\\\texttt{SimulatedAnnealing}.
    \texttt{self.func} to funkcja której maksimum chcemy znaleźć, \texttt{self.domain} to obszar w którym szukamy maksimum, a \texttt{self.dimensions} to liczba wymiarów problemu optymalizacyjnego.

    \begin{lstlisting}[language=Python, caption={Inicjalizacja klasy SimulatedAnnealing}]
    class SimulatedAnnealing:
        def __init__(self,
                 func: Callable,
                 domain: tuple[float, float] | list[tuple[float, float]]):
        self.func = func
        if isinstance(domain, tuple) and len(domain) == 2 and isinstance(
                domain[0], (int, float)):
            self.domain = [domain]
        else:
            self.domain = domain
        self.dimensions = len(self.domain)
    \end{lstlisting}

    Metoda \texttt{run\_epochs} klasy \texttt{SimulatedAnnealing} odpowiada za przeprowadzenie określonej liczby epok algorytmu symulowanego wyżarzania. 
    W każdej epoce algorytm wykonuje określoną liczbę iteracji, w trakcie których poszukuje lepszego rozwiązania.\\
    \texttt{epochs} to liczba epok do wykonania, \texttt{attempts\_per\_epoch} to liczba prób w każdej epoce, \texttt{init\_temp} to początkowa temperatura, \texttt{alpha} to funkcja schładzająca temperaturę, a \texttt{k} to współczynnik wpływający na prawdopodobieństwo akceptacji gorszych rozwiązań.
    \begin{lstlisting}[language=Python, caption={Metoda run\_epochs klasy SimulatedAnnealing}]
    def run_epochs(self,
                   epochs: int,
                   attempts_per_epoch: int,
                   init_temp: float,
                   alpha: Callable[[float], float],
                   k: float) -> tuple[list[float], float]:
    \end{lstlisting}

    Na początku metody \texttt{run\_epochs} zajmujemy się inicjalizacją dwóch wartości.
    Początkowy punkt (nieograniczony do jednego wymiaru) jest wybierany losowo z podanego przedziału lub obszaru określonego przez \texttt{self.domain}. 
    Wartość funkcji w tym punkcie jest obliczana i przechowywana jako \texttt{best\_f\_value}. Temperatura jest inicjalizowana wartością \texttt{init\_temp}.

    \begin{lstlisting}[language=Python, caption={Wybór losowego punktu oraz inicjalizacja temperatury}]
    best_point = [uniform(self.domain[i][0], self.domain[i][1])
                      for i in range(self.dimensions)]
    best_f_value = self.func(*best_point)
    temp = init_temp
    \end{lstlisting}

    \newpage

    W dalszej części metody \texttt{run\_epochs} znajduje się główna pętla algorytmu symulowanego wyżarzania.
    Główna pętla algorytmu (ta z warunkiem stopu) składa się z dwóch zagnieżdżonych pętli: zewnętrznej, która iteruje przez określoną liczbę epok, oraz wewnętrznej, która wykonuje 
    określoną liczbę prób w każdej epoce. W każdej próbie generowany jest nowy punkt poprzez wybranie go z losowego sąsiedztwa aktualnie najlepszego punktu, z 
    uwzględnieniem bieżącej temperatury. Wartość funkcji w nowym punkcie jest obliczana i porównywana z najlepszą dotychczasową wartością. Jeśli nowa wartość jest 
    lepsza, to staje się nowym najlepszym punktem. Jeśli jest gorsza, to istnieje prawdopodobieństwo akceptacji tego gorszego rozwiązania, które zależy od różnicy 
    wartości funkcji oraz bieżącej temperatury. Na koniec każdej epoki temperatura jest schładzana za pomocą funkcji \texttt{alpha}. Jeżeli wartość temperatury
    spadnie poniżej bardzo małej wartości (1e-10), pętla zostaje przerwana.

    \begin{lstlisting}[language=Python, caption={Główna pętla algorytmu symulowanego wyżarzania}]
    for _ in range(epochs):
        for _ in range(attempts_per_epoch):
            new_point = []
            for i in range(self.dimensions):
                left, right = self.domain[i]
                new_coord = uniform(best_point[i] - 2 * temp,
                                    best_point[i] + 2 * temp)
                new_coord = max(left, min(new_coord, right))
                new_point.append(new_coord)

            f_value = self.func(*new_point)

            if f_value > best_f_value:
                best_point, best_f_value = new_point, f_value
            else:
                p = uniform(0, 1)
                if exp((f_value - best_f_value) / (k * temp)) > p:
                    best_point, best_f_value = new_point, f_value

        temp = alpha(temp)
        if temp < 1e-10:
            break

    return best_point, best_f_value
    \end{lstlisting}

    \subsection{Opis uruchomienia programu}
    

    \newpage
    \section{Odtworzenie eksperymentów z artykułu}
    \subsection{Wybrana funkcja z rozdziału 3}

    \vspace{1em}
    Z sekcji 3 wybraliśmy funkcję \(f(x)\) z przykładu 1, określoną w przedziale \([-150, 150]\), wyrażoną wzorem:
    \vspace{0.5em}
    \[
    f(x) =
    \begin{cases}
        -2|x+100|+10 & \text{ dla } x\in(-105,-95) \\
        -2.2|x-100|+11 & \text{ dla } x\in(95,105) \\
        0 & \text{ dla } x\notin(-105,-95)\cup(95,105)
    \end{cases}
    \]
    \vspace{-1.75em}
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/func_section_3.png}
        \caption{Wykres funkcji \(f(x)\) w przedziale \([-150, 150]\) z oznaczonym znalezionym maksimum}
        \label{fig:wykres_sekcja_3}
    \end{figure}

    Wybrana funkcja posiada dwa ekstrema lokalne - \(f(-100) = 10\) oraz \(f(100) = 11\). Funkcja poza okolicami tych ekstremów przyjmuje wartość \(0\). Jej maksimum globalne to \(f(100) = 11\).

    Znalezione przez nas maksimum funkcji \(f(x)\) to \(f(100.27) = 10.40\) (rysunek \ref{fig:wykres_sekcja_3}), co różni się od maksimum globalnego o \(\delta=|10.84-11|=0.16\).

    \newpage
    \subsection{Wybrana funkcja z rozdziału 4}

    \vspace{1em}
    Z sekcji 4 wybraliśmy funkcję \(f(x)\) z przykładu 5, określoną w obszarze \([-3,12]\times[4.1,5.8]\), wyrażoną wzorem:
    \vspace{0.5em}
    \[
    f(x,y)=21.5+x\cdot\sin(4\cdot\pi\cdot x)+y\cdot\sin(20\cdot\pi\cdot y)
    \]
    \vspace{-1.75em}
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/func_section_4.png}
        \caption{Wykres funkcji \(f(x,y)\) w obszarze \([-3,12]\times[4.1,5.8]\) z oznaczonym znalezionym maksimum oraz maksimum globalnym}
        \label{fig:wykres_sekcja_4}
    \end{figure}

    Wybrana funkcja posiada bardzo dużo ekstremów lokalnych w określonym obszarze. Jej maksimum globalne to \(f(12,5.7) = 38.85\).

    Znalezione przez nas maksimum funkcji \(f(x,y)\) to \(f(11.12,5.62) = 38.20\) (rysunek \ref{fig:wykres_sekcja_4}), co różni się od maksimum globalnego o \(\delta=|38.20-38.85|=0.65\).

    \newpage

    \section{Wnioski}



\end{document}