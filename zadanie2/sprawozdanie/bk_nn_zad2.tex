\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[a4paper, margin=3cm]{geometry}
\usepackage{array}
\usepackage{tocloft}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Kod}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue
}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\begin{document}
    \title{Metaheurystyki --- zadanie 2 \\
    \large Algorytm symulowanego wyżarzania \\
    \small GRUPA 3 --- piątek 10:15}
    \date{\today}
    \author{
        Bartosz Kołaciński \\
        251554
        \and
        Nikodem Nowak \\
        251598
    }
    \maketitle

    \vfill
    \begin{center}
        \begin{tabular}{lr}
            \toprule
            \textbf{Użyte technologie} & Python 3.13 \\
            \midrule
            \textbf{Użyte biblioteki} & \begin{tabular}[t]{@{}r@{}}
                random, collections.abc, \\
                time, math, numpy, \\
                matplotlib.pyplot
            \end{tabular} \\
            \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1cm}

    \newpage

    \tableofcontents

    \newpage
    \section{Opis zasad działania algorytmu}
    \subsection{Opis algorytmu symulowanego wyżarzania}

    Algorytm symulowanego wyżarzania to metaheurystyka inspirowana procesem fizycznym wyżarzania metali.
    Celem algorytmu jest znalezienie przybliżonego ekstremum danej funkcji.
    Algorytm rozpoczyna się od losowego rozwiązania początkowego i iteracyjnie poszukuje lepszych rozwiązań poprzez generowanie nowych kandydatów w sąsiedztwie aktualnego rozwiązania.
    W każdej iteracji, jeśli nowe rozwiązanie jest lepsze od aktualnego, zostaje zaakceptowane jako nowe rozwiązanie.
    Jeśli jest gorsze, może zostać zaakceptowane z pewnym prawdopodobieństwem, które zależy od różnicy jakości rozwiązań oraz bieżącej temperatury i współczynnika \(k\).
    Temperatura jest stopniowo obniżana w trakcie działania algorytmu, co zmniejsza prawdopodobieństwo akceptacji gorszych rozwiązań oraz zmniejsza obszar poszukiwań.

    \subsection{Opis implementacji rozwiązania}

    Cała logika algorytmu symulowanego wyżarzania została zaimplementowana w klasie\\\texttt{SimulatedAnnealing}.
    \texttt{self.func} to funkcja której maksimum chcemy znaleźć, \texttt{self.domain} to obszar w którym szukamy maksimum, a \texttt{self.dimensions} to liczba wymiarów problemu optymalizacyjnego.

    \begin{lstlisting}[language=Python, caption={Inicjalizacja klasy SimulatedAnnealing}]
    class SimulatedAnnealing:
        def __init__(self,
                 func: Callable,
                 domain: tuple[float, float] | list[tuple[float, float]])
    \end{lstlisting}

    Metoda \texttt{run\_epochs} klasy \texttt{SimulatedAnnealing} odpowiada za przeprowadzenie określonej liczby epok algorytmu symulowanego wyżarzania. 
    W każdej epoce algorytm wykonuje określoną liczbę iteracji, w trakcie których poszukuje lepszego rozwiązania.\\
    \texttt{epochs} to liczba epok do wykonania, \texttt{attempts\_per\_epoch} to liczba prób w każdej epoce, \texttt{init\_temp} to początkowa temperatura, \texttt{alpha} to funkcja schładzająca temperaturę, a \texttt{k} to współczynnik wpływający na prawdopodobieństwo akceptacji gorszych rozwiązań.
    \begin{lstlisting}[language=Python, caption={Metoda run\_epochs klasy SimulatedAnnealing}]
    def run_epochs(self,
                   epochs: int,
                   attempts_per_epoch: int,
                   init_temp: float,
                   alpha: Callable[[float], float],
                   k: float) -> tuple[list[float], float]:
    \end{lstlisting}

    Na początku metody \texttt{run\_epochs} zajmujemy się inicjalizacją wartości.
    Początkowy punkt (nieograniczony do jednego wymiaru) jest wybierany losowo z podanego przedziału lub obszaru określonego przez \texttt{self.domain}. 
    Wartość funkcji w tym punkcie jest obliczana i przechowywana jako \texttt{best\_f\_value}. Temperatura jest inicjalizowana wartością \texttt{init\_temp}.

    \begin{lstlisting}[language=Python, caption={Wybór losowego punktu oraz inicjalizacja temperatury}]
    best_point = [uniform(self.domain[i][0], self.domain[i][1])
                      for i in range(self.dimensions)]
    best_f_value = self.func(*best_point)
    temp = init_temp
    \end{lstlisting}

    \newpage

    Fragment tworzy nowy punkt będący kandydatem do bycia nowym najlepszym punktem.
    Pętla losuje współrzędną z sąsiedztwa najlepszego rozwiązania,
    ogranicza ją do wcześniej podanej dziedziny lub obszaru i dodaje do \texttt{new\_point}.
    Dzięki zależności zakresu losowania od temperatury algorytm przy wysokiej temperaturze eksploruje dalej,
    a przy niskiej koncentruje się wokół bieżącego najlepszego rozwiązania.

    \begin{lstlisting}[language=Python, caption={Główna pętla algorytmu symulowanego wyżarzania}]
    new_point = []
    for i in range(self.dimensions):
        left, right = self.domain[i]
        new_coord = uniform(best_point[i] - 2 * temp,
                            best_point[i] + 2 * temp)
        new_coord = max(left, min(new_coord, right))
        new_point.append(new_coord)
    \end{lstlisting}

    Gorsze rozwiązanie zostaje zaakceptowane gdy zajdzie warunek \( e^{\frac{f(x') - f(x)}{kT}} > p \), gdzie \(p\) to losowa liczba z przedziału \([0, 1]\),
    \(f(x')\) to wartość funkcji w nowym punkcie, \(f(x)\) to wartość funkcji w najlepszym dotychczasowym punkcie, \(k\) to współczynnik wpływający na prawdopodobieństwo
    akceptacji gorszych rozwiązań, a \(T\) to bieżąca temperatura.

    \begin{lstlisting}[language=Python, caption={Główna pętla algorytmu symulowanego wyżarzania}]
    p = uniform(0, 1)
    if exp((f_value - best_f_value) / (k * temp)) > p:
        best_point, best_f_value = new_point, f_value
    \end{lstlisting}

    \subsection{Opis uruchomienia programu}
    

    \newpage
    \section{Odtworzenie eksperymentów z artykułu}
    \subsection{Wybrana funkcja z rozdziału 3}

    \vspace{1em}
    Z sekcji 3 wybraliśmy funkcję \(f(x)\) z przykładu 1, określoną w przedziale \([-150, 150]\), wyrażoną wzorem:
    \vspace{0.5em}
    \[
    f(x) =
    \begin{cases}
        -2|x+100|+10 & \text{ dla } x\in(-105,-95) \\
        -2.2|x-100|+11 & \text{ dla } x\in(95,105) \\
        0 & \text{ dla } x\notin(-105,-95)\cup(95,105)
    \end{cases}
    \]
    \vspace{-1.75em}
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/func_section_3.png}
        \caption{Wykres funkcji \(f(x)\) w przedziale \([-150, 150]\) z oznaczonym znalezionym maksimum}
        \label{fig:wykres_sekcja_3}
    \end{figure}

    Wybrana funkcja posiada dwa ekstrema lokalne - \(f(-100) = 10\) oraz \(f(100) = 11\). Funkcja poza okolicami tych ekstremów przyjmuje wartość \(0\). Jej maksimum globalne to \(f(100) = 11\).

    Znalezione przez nas maksimum funkcji \(f(x)\) to \(f(100.27) = 10.40\) (rysunek \ref{fig:wykres_sekcja_3}), co różni się od maksimum globalnego o \(\delta=|10.84-11|=0.16\).

    \newpage
    \subsection{Wybrana funkcja z rozdziału 4}

    \vspace{1em}
    Z sekcji 4 wybraliśmy funkcję \(f(x)\) z przykładu 5, określoną w obszarze \([-3,12]\times[4.1,5.8]\), wyrażoną wzorem:
    \vspace{0.5em}
    \[
    f(x,y)=21.5+x\cdot\sin(4\cdot\pi\cdot x)+y\cdot\sin(20\cdot\pi\cdot y)
    \]
    \vspace{-1.75em}
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/func_section_4.png}
        \caption{Wykres funkcji \(f(x,y)\) w obszarze \([-3,12]\times[4.1,5.8]\) z oznaczonym znalezionym maksimum oraz maksimum globalnym}
        \label{fig:wykres_sekcja_4}
    \end{figure}

    Wybrana funkcja posiada bardzo dużo ekstremów lokalnych w określonym obszarze. Jej maksimum globalne to \(f(12,5.7) = 38.85\).

    Znalezione przez nas maksimum funkcji \(f(x,y)\) to \(f(11.12,5.62) = 38.20\) (rysunek \ref{fig:wykres_sekcja_4}), co różni się od maksimum globalnego o \(\delta=|38.20-38.85|=0.65\).

    \newpage

    \subsection{Analiza wpływu parametrów algorytmu na jakość rozwiązania}

    \subsubsection{Analiza wpływu temperatury na jakość rozwiązania}

    Wartość temperatury początkowej ma istotny wpływ na dokładność rozwiązania (co widać na rysunku \ref{fig:temperatura_analiza}), ale nie ma wpływu na czas trwania algorytmu ani na liczbę iteracji.

    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/temperature_overview.png}
        \caption{Zależności pomiędzy wartością temperatury początkowej a czasem, ilością iteracji oraz jakością rozwiązania}
        \label{fig:temperatura_analiza}
    \end{figure}

    \newpage

    \subsubsection{Analiza wpływu alpha na jakość rozwiązania}

    Wartość współczynnika \(\alpha\) ma istotny wpływ na wszystkie trzy badane aspekty: czas trwania algorytmu, liczbę iteracji oraz dokładność rozwiązania (co widać na rysunku \ref{fig:alpha_analiza}).
    Wykres zależności pomiędzy wartością \(\alpha\) a czasem oraz liczbą iteracji przyjmują charakterystyczny kształt ze względu na drugi warunek stopu, którym jest osiągnięcie niskiej wartości temperatury.

    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/alpha_overview.png}
        \caption{Zależności pomiędzy wartością współczynnika \(\alpha\) a czasem, ilością iteracji oraz jakością rozwiązania}
        \label{fig:alpha_analiza}
    \end{figure}

    \newpage

    \subsubsection{Analiza wpływu liczby epok na jakość rozwiązania}

    Liczba epok wpływa na wszystkie trzy badane aspekty: czas trwania algorytmu, liczbę iteracji oraz dokładność rozwiązania. Pomiędzy ilością epok a czasem wykonania oraz pomiędzy ilością epok a ilością iteracji
    potrzebnych do znalezienia najlepszego rozwiązania łatwo zauważyć zależność liniową (co widać na rysunku \ref{fig:epoki_analiza}). Zbyt niska wartość liczby epok skutkuje słabą dokładnością rozwiązania.

    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/epochs_overview.png}
        \caption{Zależności pomiędzy liczbą epok a czasem, ilością iteracji oraz jakością rozwiązania}
        \label{fig:epoki_analiza}
    \end{figure}

    \newpage

    \section{Wnioski}


\end{document}