\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[a4paper, margin=3cm]{geometry}
\usepackage{array}
\usepackage{tocloft}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Kod}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue
}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\begin{document}
    \title{Metaheurystyki --- zadanie 4 \\
    \large Algorytm mrówkowy (ACO) \\
    \small GRUPA 3 --- piątek 10:15}
    \date{\today}
    \author{
        Bartosz Kołaciński \\
        251554
        \and
        Nikodem Nowak \\
        251598
    }
    \maketitle

    \vfill
    \begin{center}
        \begin{tabular}{lr}
            \toprule
            \textbf{Użyte technologie} & Python 3.13 \\
            \midrule
            \textbf{Użyte biblioteki} & \begin{tabular}[t]{@{}r@{}}
                random, math, time, \\
                numpy, pandas, \\
                matplotlib.pyplot
            \end{tabular} \\
            \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1cm}

    \newpage

    \tableofcontents

    \newpage

    \section{Opis zasad działania algorytmu}
    \subsection{Opis problemu}
    
    Problem polega na znalezieniu najkrótszej trasy odwiedzającej wszystkie atrakcje w wesołym miasteczku.
    Jest to wariant problemu komiwojażera (ang. \textit{Traveling Salesman Problem}, TSP).
    Dany jest zbiór punktów (atrakcji) o określonych współrzędnych na płaszczyźnie.
    Celem jest znalezienie takiej kolejności odwiedzenia wszystkich punktów, aby łączna przebyta odległość była jak najmniejsza.

    \subsection{Opis algorytmu mrówkowego (ACO)}

    Algorytm mrówkowy (Ant Colony Optimization) to metaheurystyka inspirowana zachowaniem mrówek szukających pożywienia.
    Mrówki w naturze komunikują się za pomocą feromonów --- substancji chemicznych pozostawianych na trasie.
    Ścieżki z większą ilością feromonu są chętniej wybierane przez kolejne mrówki.
    
    \subsubsection{Pseudokod algorytmu}
    
    \begin{algorithm}[H]
    \caption{Algorytm mrówkowy (ACO)}
    \begin{algorithmic}[1]
    \State \textbf{Inicjalizacja:}
    \State Zainicjuj macierz feromonów $\tau_{ij} \gets 1.0$ dla wszystkich krawędzi $(i,j)$
    \State Oblicz macierz odległości $d_{ij}$ dla wszystkich par wierzchołków
    \For{$t = 1$ \textbf{to} $T$ (liczba iteracji)}
        \State \textbf{Konstrukcja tras:}
        \For{każda mrówka $k = 1, \ldots, m$}
            \State Wybierz losowy wierzchołek startowy
            \While{nie odwiedzono wszystkich wierzchołków}
                \State Wybierz następny wierzchołek $j$ z prawdopodobieństwem:
                \State $p_{ij} = \frac{[\tau_{ij}]^\alpha \cdot [\eta_{ij}]^\beta}{\sum_{l \in \text{dozwolone}} [\tau_{il}]^\alpha \cdot [\eta_{il}]^\beta}$
                \State gdzie $\eta_{ij} = 1/d_{ij}$ (heurystyka odwrotności odległości)
            \EndWhile
            \State Oblicz długość trasy mrówki $k$
        \EndFor
        \State \textbf{Aktualizacja feromonów:}
        \State Wyparowanie: $\tau_{ij} \gets (1-\rho) \cdot \tau_{ij}$ dla wszystkich $(i,j)$
        \For{każda mrówka $k$}
            \State Depozyt: $\tau_{ij} \gets \tau_{ij} + \Delta\tau_{ij}^k$ na trasie mrówki
            \State gdzie $\Delta\tau_{ij}^k = 1/L_k$ ($L_k$ --- długość trasy mrówki $k$)
        \EndFor
        \State Zaktualizuj najlepsze znalezione rozwiązanie
    \EndFor
    \State \Return najlepsza znaleziona trasa
    \end{algorithmic}
    \end{algorithm}

    \subsubsection{Parametry algorytmu}
    \begin{itemize}
        \item $m$ --- liczba mrówek w kolonii
        \item $\alpha$ --- wpływ feromonów na wybór ścieżki
        \item $\beta$ --- wpływ heurystyki (odwrotności odległości) na wybór ścieżki
        \item $\rho$ --- współczynnik wyparowywania feromonów (0 $<$ $\rho$ $<$ 1)
        \item $T$ --- liczba iteracji algorytmu
        \item $p_{random}$ --- prawdopodobieństwo losowego wyboru (eksploracja)
    \end{itemize}

    \subsection{Opis implementacji rozwiązania}

    \subsubsection{Reprezentacja grafu i obliczanie odległości}
    
    Graf jest reprezentowany jako macierz odległości euklidesowych między wszystkimi parami atrakcji.
    Dane wejściowe są wczytywane z pliku tekstowego w formacie: \texttt{nrAtrakcji współrzędnaX współrzędnaY}.

    \begin{lstlisting}[language=Python, caption={Wczytywanie danych i obliczanie macierzy odległości}]
def read_data(filepath: str, separator: str = ' ') -> tuple:
    from math import dist
    import pandas as pd

    data_csv = list(pd.read_csv(
        filepath, sep=separator, skipinitialspace=True, header=None
    ).to_records(index=False))
    data_csv = [(int(row[0]), int(row[1]), int(row[2])) for row in data_csv]

    data_length = len(data_csv)
    distances_matrix = [[0.0] * data_length for _ in range(data_length)]
    for i in range(data_length):
        for j in range(data_length):
            if i != j:
                p1 = (data_csv[i][1], data_csv[i][2])
                p2 = (data_csv[j][1], data_csv[j][2])
                distances_matrix[i][j] = dist(p1, p2)

    index_to_id_map = {i: rec[0] for i, rec in enumerate(data_csv)}
    return data_csv, distances_matrix, index_to_id_map
    \end{lstlisting}

    \subsubsection{Reprezentacja trasy i kosztu}
    
    Trasa jest reprezentowana jako lista indeksów odwiedzonych wierzchołków.
    Koszt (długość trasy) jest obliczany jako suma odległości między kolejnymi wierzchołkami.

    \begin{lstlisting}[language=Python, caption={Obliczanie długości trasy}]
def get_path_length(self) -> float:
    length = 0.0
    for i in range(len(self.visited) - 1):
        l1 = self.visited[i]
        l2 = self.visited[i + 1]
        length += self.distances_matrix[l1][l2]
    return length
    \end{lstlisting}

    \subsubsection{Inicjalizacja feromonów}
    
    Macierz feromonów jest inicjalizowana wartością 1.0 dla wszystkich krawędzi.

    \begin{lstlisting}[language=Python, caption={Inicjalizacja feromonów}]
self.pheromones = [
    [1.0] * self.num_attractions for _ in range(self.num_attractions)
]
    \end{lstlisting}

    \subsubsection{Mechanizm konstrukcji trasy (reguła wyboru)}
    
    Mrówka wybiera następny wierzchołek na podstawie prawdopodobieństwa zależnego od feromonów i heurystyki.
    Z małym prawdopodobieństwem $p_{random}$ może wybrać losowy wierzchołek (eksploracja).

    \begin{lstlisting}[language=Python, caption={Wybór następnego wierzchołka przez mrówkę}]
def select_next_node(self, p_random: float) -> None:
    current_node = self.visited[-1]
    allowed_nodes = list(set(range(self.num_attractions)) - set(self.visited))

    if not allowed_nodes:
        return

    # Losowy wybor (eksploracja)
    if random.random() < p_random:
        next_node = random.choice(allowed_nodes)
        self.visited.append(next_node)
        return

    # Wybor na podstawie feromonow i heurystyki
    possibilities = self._calculate_possibilities(current_node, allowed_nodes)
    next_node = random.choices(allowed_nodes, weights=possibilities)[0]
    self.visited.append(next_node)

def _calculate_possibilities(self, current_node, allowed_nodes):
    scores = []
    denominator = 0.0
    
    for node in allowed_nodes:
        tau = Ant.pheromones[current_node][node]
        distance = Ant.distances_matrix[current_node][node]
        if distance == 0:
            distance = 1e-10  # Obsluga zerowej odleglosci
        eta = 1.0 / distance
        
        score = (tau ** Ant.alpha) * (eta ** Ant.beta)
        scores.append(score)
        denominator += score

    if denominator == 0.0:
        return [1.0 / len(allowed_nodes)] * len(allowed_nodes)
    
    return [score / denominator for score in scores]
    \end{lstlisting}

    \subsubsection{Aktualizacja feromonów i wyparowywanie}
    
    Po każdej iteracji feromony wyparowują (mnożenie przez $(1-\rho)$), a następnie mrówki deponują feromony proporcjonalnie do jakości swojej trasy.

    \begin{lstlisting}[language=Python, caption={Aktualizacja feromonów}]
def _update_pheromones(self, ants):
    evaporation_factor = 1.0 - self.rho

    # Wyparowywanie feromonow
    for i in range(self.num_attractions):
        for j in range(self.num_attractions):
            self.pheromones[i][j] *= evaporation_factor

    # Depozyt feromonow
    for ant in ants:
        path = ant.get_visited()
        path_length = ant.get_path_length()

        if path_length > 0:
            deposit = 1.0 / path_length
            for i in range(len(path) - 1):
                from_node = path[i]
                to_node = path[i + 1]
                self.pheromones[from_node][to_node] += deposit
                self.pheromones[to_node][from_node] += deposit
    \end{lstlisting}

    \subsection{Instrukcja uruchomienia programu}

    Program uruchamia się poprzez wywołanie pliku \texttt{main.py}:
    \begin{center}
        \texttt{python main.py}
    \end{center}
    
    Program jest interaktywny i prosi użytkownika o:
    \begin{enumerate}
        \item Wybór pliku z danymi (A-n32-k5.txt lub A-n80-k10.txt).
        \item Podanie parametrów algorytmu:
        \begin{itemize}
            \item Liczba mrówek ($m$)
            \item Liczba iteracji ($T$)
            \item Wpływ feromonów ($\alpha$)
            \item Wpływ heurystyki ($\beta$)
            \item Współczynnik wyparowywania ($\rho$)
            \item Prawdopodobieństwo losowego wyboru ($p_{random}$)
        \end{itemize}
    \end{enumerate}
    
    Po zakończeniu działania wyświetlane są: najlepsza znaleziona trasa (kolejność atrakcji) oraz jej długość.

    W celu wygenerowania wszystkich eksperymentów opisanych w dalszej części sprawozdania, należy uruchomić skrypt:
    \begin{center}
        \texttt{python all\_experiments.py}
    \end{center}
    
    Wykresy generuje się komendą:
    \begin{center}
        \texttt{python plots.py}
    \end{center}

    \newpage

    \section{Eksperymenty i wyniki}

    Przeprowadzono serię eksperymentów dla dwóch zbiorów danych:
    \begin{itemize}
        \item \textbf{A-n32-k5} --- 32 atrakcje
        \item \textbf{A-n80-k10} --- 80 atrakcji
    \end{itemize}
    
    Dla każdej konfiguracji algorytm był uruchamiany 5 razy w celu uzyskania statystyk.
    Wykresy z analizą wpływu parametrów przedstawione w dalszej części dotyczą instancji \textbf{A-n80-k10}, jako że jest ona bardziej wymagająca obliczeniowo i lepiej pokazuje różnice między konfiguracjami.

    \subsection{Najlepsze znalezione rozwiązania}

    Poniżej przedstawiono wizualizacje najlepszych tras znalezionych przez algorytm dla obu instancji testowych.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n32-k5/best_route.png}
        \caption{Najlepsza znaleziona trasa dla instancji A-n32-k5. Zielona gwiazdka oznacza punkt startowy, a czerwony kwadrat --- punkt końcowy trasy. Uzyskany koszt to 423.83 jednostki.}
        \label{fig:best_route_32}
    \end{figure}

    Dla mniejszej instancji (32 atrakcje) uzyskana trasa nie zawiera przecięć, a punkty są odwiedzane w logicznej kolejności

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/best_route.png}
        \caption{Najlepsza znaleziona trasa dla instancji A-n80-k10. Przy 80 atrakcjach problem jest znacznie trudniejszy, ale algorytm mrówkowy nadal znajduje rozsądne rozwiązanie o koszcie 734.37.}
        \label{fig:best_route_80}
    \end{figure}

    Dla większej instancji (80 atrakcji) algorytm również znajduje rozwiązanie bez znaczących przecięć.

    \newpage
    \subsection{Wpływ liczby mrówek ($m$)}
    
    Badano wartości: $m \in \{10, 20, 50, 100\}$.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_m.png}
        \caption{Wpływ liczby mrówek na średnią długość trasy. Słupki błędów pokazują odchylenie standardowe z 5 uruchomień. Im niższy słupek, tym lepszy wynik.}
        \label{fig:influence_population}
    \end{figure}

    Różnice między poszczególnymi wartościami są umiarkowane --- wszystkie wyniki mieszczą się w przedziale 750--770.
    
    \textbf{Obserwacje:}
    \begin{itemize}
        \item Przy $m = 10$ uzyskano najgorszy średni wynik ($\sim$770) oraz największe odchylenie standardowe.
        \item Zwiększenie do $m = 50$--$100$ daje poprawę o około 15--20 jednostek i zmniejsza wariancję wyników.
        \item Wartość $m = 20$--$50$ stanowi rozsądny kompromis między jakością rozwiązania a czasem obliczeń.
    \end{itemize}

    \newpage
    \subsection{Wpływ prawdopodobieństwa losowego wyboru ($p_{random}$)}
    
    Badano wartości: $p_{random} \in \{0.0, 0.01, 0.05, 0.1\}$.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_p_random.png}
        \caption{Wpływ prawdopodobieństwa losowego wyboru na średnią długość trasy. Wyraźnie widać, że zbyt duża losowość psuje wyniki.}
        \label{fig:influence_p_random}
    \end{figure}

    Ten parametr wykazuje najsilniejszy wpływ na jakość rozwiązania spośród wszystkich badanych.
    
    \textbf{Obserwacje:}
    \begin{itemize}
        \item Wartości $p_{random} = 0.0$ i $p_{random} = 0.01$ dają praktycznie identyczne wyniki ($\sim$760).
        \item Przy $p_{random} = 0.05$ średni koszt rośnie do około 830.
        \item Przy $p_{random} = 0.1$ wynik pogarsza się do $\sim$945 --- prawie 200 jednostek więcej niż bez losowości.
    \end{itemize}
    
    Zbyt duże prawdopodobieństwo losowego wyboru zaburza proces uczenia oparty na feromonach. Zalecana wartość: $p_{random} \leq 0.01$.

    \newpage
    \subsection{Wpływ współczynnika $\alpha$ (wpływ feromonów)}
    
    Badano wartości: $\alpha \in \{0.5, 1.0, 2.0, 5.0\}$.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_alpha.png}
        \caption{Wpływ współczynnika $\alpha$ na średnią długość trasy. Zbyt niska wartość $\alpha$ oznacza ignorowanie feromonów.}
        \label{fig:influence_alpha}
    \end{figure}
    
    \textbf{Obserwacje:}
    \begin{itemize}
        \item $\alpha = 0.5$ daje najgorszy wynik ($\sim$900) --- zbyt słaby wpływ feromonów ogranicza uczenie kolektywne.
        \item $\alpha = 1.0$ i $\alpha = 2.0$ dają podobne, dobre wyniki ($\sim$760).
        \item $\alpha = 5.0$ jest nieznacznie gorsze ($\sim$770) z większą wariancją --- zbyt silny wpływ feromonów powoduje przedwczesną zbieżność.
    \end{itemize}
    
    Optymalne wartości to $\alpha = 1.0$--$2.0$, zapewniające równowagę między eksploracją a eksploatacją.

    \newpage
    \subsection{Wpływ współczynnika $\beta$ (wpływ heurystyki)}
    
    Badano wartości: $\beta \in \{1.0, 2.0, 5.0, 10.0\}$.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_beta.png}
        \caption{Wpływ współczynnika $\beta$ na średnią długość trasy. Wyższe $\beta$ oznacza większą ''zachłanność'' --- mrówki preferują bliskie wierzchołki.}
        \label{fig:influence_beta}
    \end{figure}
    
    \textbf{Obserwacje:}
    \begin{itemize}
        \item $\beta = 1.0$ daje najgorszy wynik ($\sim$850) --- zbyt słaba preferencja bliskich wierzchołków.
        \item $\beta = 2.0$ znacząco poprawia wynik ($\sim$760).
        \item $\beta = 5.0$ i $\beta = 10.0$ dają najlepsze wyniki ($\sim$745--750).
    \end{itemize}
    
    Wysokie wartości $\beta$ nie powodują utknięcia w lokalnych minimach. Silna heurystyka odległościowa jest korzystna dla problemu TSP.

    \newpage
    \subsection{Wpływ liczby iteracji ($T$)}
    
    Badano wartości: $T \in \{100, 500, 1000\}$.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_iterations.png}
        \caption{Wpływ liczby iteracji na średnią długość trasy. Więcej iteracji = więcej czasu na szukanie, ale zysk jest niewielki.}
        \label{fig:influence_iterations}
    \end{figure}
    
    \textbf{Obserwacje:}
    \begin{itemize}
        \item Różnice są niewielkie --- wszystkie wyniki mieszczą się w przedziale 740--755.
        \item Przy $T = 100$ średni koszt wynosi około 755, przy $T = 1000$ --- około 740.
        \item Dziesięciokrotny wzrost liczby iteracji daje poprawę o jedynie 15 jednostek.
    \end{itemize}
    
    Algorytm szybko osiąga stabilizację. Dla badanych instancji $T = 100$--$500$ jest wystarczające.

    \newpage
    \subsection{Wpływ współczynnika wyparowywania ($\rho$)}
    
    Badano wartości: $\rho \in \{0.1, 0.3, 0.5, 0.8\}$.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.85\textwidth]{../plots/A-n80-k10/influence_rho.png}
        \caption{Wpływ współczynnika wyparowywania $\rho$ na średnią długość trasy. Parametr kontroluje, jak szybko ''zapominane'' są stare ścieżki.}
        \label{fig:influence_evaporation}
    \end{figure}
    
    \textbf{Co widzimy:}
    \begin{itemize}
        \item $\rho = 0.1$ (wolne wyparowywanie) daje najgorszy wynik ($\sim$795) --- stare feromony zbyt długo wpływają na decyzje.
        \item $\rho = 0.3$, $\rho = 0.5$ i $\rho = 0.8$ dają bardzo podobne wyniki ($\sim$760--765).
        \item W praktyce nie ma dużej różnicy między wartościami 0.3--0.8.
    \end{itemize}
    
    Kluczowe jest unikanie zbyt niskiej wartości $\rho$, która powoduje nadmierne utrzymywanie starych ścieżek feromonowych.

    \newpage

    \section{Wnioski}

    Na podstawie przeprowadzonych eksperymentów sformułowano następujące wnioski:
    
    \begin{itemize}
        \item \textbf{Skuteczność algorytmu}: Dla obu instancji uzyskano trasy o kosztach 423.83 (32 atrakcje) i 734.37 (80 atrakcji).
        
        \item \textbf{Liczba mrówek}: Zwiększenie z 10 do 100 mrówek daje poprawę o około 20 jednostek. Zalecana wartość: $m = 20$--$50$.
        
        \item \textbf{Prawdopodobieństwo losowego wyboru}: Wartości $p_{random} > 0.01$ znacząco pogarszają wyniki (nawet o 200 jednostek dla $p_{random} = 0.1$). Zalecane: $p_{random} \leq 0.01$.
        
        \item \textbf{Wpływ heurystyki ($\beta$)}: Wyższe wartości ($\beta = 5.0$--$10.0$) dają lepsze wyniki niż standardowe $\beta = 2.0$. Silniejsza preferencja bliskich wierzchołków poprawia jakość tras.
        
        \item \textbf{Wpływ feromonów ($\alpha$)}: Optymalne wartości to $\alpha = 1.0$--$2.0$. Zbyt niskie ($\alpha = 0.5$) osłabia uczenie, zbyt wysokie ($\alpha = 5.0$) przyspiesza przedwczesną zbieżność.
        
        \item \textbf{Liczba iteracji}: Różnica między 100 a 1000 iteracji wynosi około 15 jednostek --- algorytm szybko osiąga stabilizację.
        
        \item \textbf{Współczynnik wyparowywania}: Wartość $\rho = 0.1$ daje gorsze wyniki, natomiast $\rho \in \{0.3, 0.5, 0.8\}$ działają porównywalnie.
    \end{itemize}

    \subsection{Rekomendowane parametry}
    
    Na podstawie naszych eksperymentów sugerujemy:
    \begin{center}
        \begin{tabular}{ll}
            \toprule
            \textbf{Parametr} & \textbf{Zalecana wartość} \\
            \midrule
            Liczba mrówek ($m$) & 20--50 \\
            Wpływ feromonów ($\alpha$) & 1.0--2.0 \\
            Wpływ heurystyki ($\beta$) & 5.0--10.0 \\
            Wyparowywanie ($\rho$) & 0.3--0.5 \\
            Iteracje ($T$) & 100--500 \\
            Losowy wybór ($p_{random}$) & 0.0--0.01 \\
            \bottomrule
        \end{tabular}
    \end{center}
    
    Warto zauważyć, że zalecane wartości $\beta$ są wyższe niż typowe wartości literaturowe ($\beta = 2$--$5$), co sugeruje, że dla problemu TSP silniejsza heurystyka odległościowa jest korzystna.

    \subsection{Ograniczenia eksperymentu}
    
    \begin{itemize}
        \item Każda konfiguracja była uruchomiona 5 razy --- większa liczba powtórzeń zwiększyłaby wiarygodność statystyczną.
        \item Testowano tylko dwie instancje (32 i 80 atrakcji) --- generalizacja wniosków na większe problemy wymaga dodatkowych badań.
    \end{itemize}

\end{document}
